---
layout: post
title: 테스트 플랜   
tags: [TEST]
description: >
  구글은 소프트웨어를 어떻게 테스트 하는가의 일부 내용이다. 나중에 요약할 것이다.
author: suji
---

# 테스트 계획 

개발자는 그들이 개발하는 생성물에 테스터를 포함한 누구나 관심을 갖고 피드백을 주기 때문에 이득을 볼 수 있다. 개발자는 코드를 다루고, 코드는 사용자가 원하는 애플리케이션이 되므로, 이것은 회사에 이익을 준다. 이러한 것은 프로젝트가 수행될 때 생성되는 가장 중요한 문서에 정의돼 있다.

반대로 테스터들은 문서들과 코드보다는 임시로 생성되는 산출물들을 다룬다. 프로젝트의 초기 단계에서 테스터는 테스트 계획을 세우고, 후기 단계에서는 테스트 케이스를 생성하고 수행하며, 버그 리포트를 작성한다. 추후에 그들은 커버리지 리포트와 사용자 만족도와 소프트웨어 품질에 대한 데이터를 수집한다. 소프트웨어가 릴리스 되고 성공적으로(혹은 실패해) 완료된 이후에 일부 사람들은 테스트 생성물에 대해 문의한다. 인기 있는 소프트웨어라면 사람들은 테스트를 당연시한다. 빈약한 소프트웨어라면 사람들은 테스팅에 대해 의문을 가질 것이지만, 테스팅 결과물 자체를 보려고 하려는 사람은 아마 많지 않을 것이다.

테스터는 테스트 문서를 작성할 때 자기중심적이면 안 된다. 소프트웨어 개발의 코딩, 리뷰, 빌드, 테스트, 재정비, 반복적인 주기의 고통에서 벗어나 잠깐 앉아서 테스트 계획을 바라보자. 나쁜 테스트 케이스는 충분한 주목을 끌 수 없다. 이것들은 더 나은 무언가를 위해 그냥 버려진다 .점점 발전해가는 코드베이스가 실제로 주목 받는 중요하고 유일한 생산물이고, 그래야만 한다.

테스트 문서가 작성돼 감에 따라 테스트 계획은 다른 테스트 생성물들의 실제 생명주기를 간단하게 보여줘야 한다. 프로젝트 초기에 테스트 계획을 작성해야 하는 부담감이 있다.

일부 프로젝트 매니저들은 테스트 계획이 반드시 존재해야 하고, 테스트 계획을 작성하는 것 자체가 매우 중요하다고 주장한다. 하지만 테스트 계획이 한번 작성되고 나면 작성한 매니저가 심혈을 기울여 다시 리뷰를 하거나 업데이트하기가 매우 어렵다. 테스트 계획은 의욕적으로 구매했지만 빨래 걸이가 돼버린 러닝 머신처럼 한구석에 쳐 박힌다. 언젠가 꼭 다시 운도응ㄹ 할 거라는 다짐만 하고 처분하진 않고 거실을 차지한다. 

테스트 계획은 가장 처음으로 생성되는 테스트 산출물이지만, 가장 먼저 방치된다. 프로젝트의 초창기에는 테스트 계획이 실제 소프트웨어가 의도하는 바에 대해 설명하지만, 시간이 지나 코드가 추가되고 기능이 변경됨ㅇ ㅔ따라 곧 테스트 계획은 동기화가 되지 않는 오래된 문서가 돼버린다. 계획했건 안 했건 이러한 변경 사항에 대해 테스트 계획을 유지하는 방법은 손이 많이 가는 일이며, 프로젝트의 여러 이해관계자와 정기적으로 논의해야만 가치가 있는 것이다.

테스트 계획은 아침에 배달되는 우유처럼 항상 신선하게 유지돼야 한다는 것에 그 아이디어가 숨어 있다. 테스트 계획이 실제로 제품의 저체 개발 과정을 통해서 얼마나 테스트 액티비티들을 주도해 내는가, 테스터들은 앱의 기능들을 지속적으로 나눠 할당해 테스트를 하는가, 기능이 추가되거나 수정되는 것에 따라 개발자들이 테스트 계획도 수정돼야 한다고 언급해주는가, 개발 매니저가 자신이 해야 할 일을 관리하듯 테스트 계획을 항상 열어놓고 있는가? 진행 상황 회의에서 테스트 매니저는 얼마나 자주 테스트 계획의 내용을 확인하는가를 확인해야 한다. 테스트 계획이 진짜 중요하다면 이러한 모든 일이 매일매일 일어나야 한다.

프로젝트가 수행되는 동안에는 테스트 계획이 위와 같은 중요한 역할을 해주어야 하는 것이 이상적이며, 소프트웨어가 존재하는 동안 테스트 계획 문서도 함께 존재해 코드베이스가 업데이트되면 함께 업데이트되고, 초기 제품이 아닌 현재 진행 중인 제품의 상태를 반여해야 한다. 또한 새로운 엔지니어가 이미 진행 중인 프로젝트에 참여해 제 속도를 내기 위해 필요한 문서가 돼야 한다.

이상적인 상황에서는 그렇지만 실제 상황은 다르므로 구글 등에서 실제로 달성해야 할 상황들은 좀 더 적다.

다음은 테스트 계획의 필수 사항들이다.
- 항상 최신으로 유지돼야 한다.
- 소프트웨어가 의도하는 바와 사용자에게 사랑받을 수 있는 이유가 있어야 한다.
- 소프트웨어 구조에 대한 스냅샷과 여러 컴포넌트와 기능에 대한 이름을 포함하고 있어야 한다.
- 소프트웨어가 해야 하는 것들을 설명하고, 어떻게 하는지 요약해야 한다.

순수하게 테스팅 관점에서 보면 테스트 계획의 연관성을 유지하는 것이 그 가치보다 더 부담스러운 일이 되지 않을까 걱정이 되기도 한다.

- 생성하는 데 오랜 시간이 걸리면 안 되고, 쉽게 수정할 수 있어야 한다.
- 무엇을 테스트해야 하는지 설명해야 한다.
- 테스팅하는 동안 진행 상황과 커버리지 간의 차이를 결정하는 데 도움이 돼야만 한다.

구글에서의 테스트 계획의 역사는 우리가 경험한 다른 회사와 크게 다르지 않다. 테스트 계획은 이를 수행하는 사람들이 결정하는 프로세스였으며, 개개의 팀에 따라 수행됐다. 일부 팀은 테스트 계획을 중앙 저장소에 따로 저장하지 않고, 단순히 구글 문서도구에 텍스트나 스프레드시트로 작해 공유하기도 한다. 어떤 팀들은 그들의 ㅇ테스트 계획을 제품 홈 페이지에 링크하기도 한다. 하지만 많은 팀들은 내부 구글 사이트 페이지에 있는 자신의 프로젝트 페이지에 추가하거나, 설계 문서에서 링크하거나 내부 위키에 넣어놓는다. 소수의 팀들은 마이크로소프트 워드 문서를 사용하고, 이메일을 통해 전달하는 구식 방식을 사용하기도 한다. 일부 팀들은 테스트 계획을 아예 갖고 있지도 않으며, 단지 그것을 대신하는 테스트 케이스와 그 전체 개수 정보만을 갖고 있다.

이러한 테스트 계획에 대한 컴토 경로는 알기가 어려우며, 저자와 검토자를 알아내기 힘들다. 많은 테스트 계획들이 냉장고 저 뒤편에 몇 년 동안 잊혀진 딸기 잼 통게 써진 제조 일자처럼 언제 작성된 것인지에 대한 날짜와 시간 정보를 포함하고 있다. 그 당시에는 그러한 정보가 주요했겠지만, 시간이 지나고 나서 보면 그것이 중요치 않게 된다.

모든 제품의 테스트 계획에 대해 중앙 저장소와 템플릿을 이용하라는 제안이 구글에서 있었다. 다른 곳에서는 분명 흥미로운 아이디어였겠지만, 분산된 지차체적 성격을 갖는 구글의 본질과는 정면으로 대치돼 조롱 받을 만한 대기업스러운 발상이었다.

많은 구글 테스트 팀으로부터 우수 사례가 나오고 나를 포함한 여러 제품 영역의 동료들을 불러 모은 ACC 분석에 들어가도록 하자. ACC는 초기 적용 단계를 지나 이제 다른 회사에게 소개되고 있으며, '구글 텟트 분석삭'이라는 이름 아래에 이를 자동화하고 싶은 툴 개발자들의 주목을 받고 있다.

ACC는 다음과 같은 사항을 갖고 있다.

- 서술형을 피하고 단순한 문장을 사용하라. 모든 테스터가 문학가가 꿈은 아니며, 인생에서 제품의 목적이나 테스트 필요성을 적절히 서술할 일은 거의 없다. 서술형 문장은 읽기 어려우며, 잘못 해석되기가 쉽다. 제발 단순 사실만 나열하자!
- 판매에 신경 쓰지 말자. 테스트 계획은 마케팅 문서나 틈새시장을 제품이 어떻게 공략하는지, 얼마나 제품이 훌륭한지 알려주는 문서가 아니다. 테스트 계획은 고객이나 분석가들을 위한 것이 아니라 엔지니어를 위한 것이다.
- 뻥튀기 하지 말자. 테스트 계획 문서에 정해진 길이는 없다. 테스트 계획은 페이지 수로 채점하는 대학교 교양 과목의 리포트가 아니다. 긴 것이 좋다는 편견은 버려야 한다. 테스트 계획의 크기는 테스팅 문제에 대한 크기와 관련이 있을 뿐이지, 작성자의 성향과는 상관이 없다.
- 중요하지 않고 수행할 수 없는 것이라면 테스트 계획에 넣지 말라. 잠재적 이해 관계자로부터 '상관없음'이라는 반응을 얻는 일은 아예 없어야 한다.
- 흐름을 만들어라. 텟트 계획의 각 섹션은 이전 섹션과 흐름을 이어가면서 독자가 읽는 것을 잠시 멈추고 제ㅜㅁ의 기능을 머리속에 그릴 수 있어야 한다. 독자가 좀 더 상세한 사항을 알고 싶다면 속 읽어나가기만 하면 되게 하자.
- 테스트 계획을 작성한 사람의 생각을 안내하라. 좋은 기획 프로세스는 기획자가 기능과 테스트 필요성에 대해 생각하는 것을 도우며, 논리적으로 상위 레벨의 개념 단계에서 하위 레벨의 상세 단계까지 직통으로 연결되게 이끌어야 한다.
- 최종 결과물은 테스트 케이스여야 한다. 테스트 계획이 완성되는 순간 테스트 필요성이 무엇인지 설명하는 것에 그쳐서는 안 되고, 명확한 테스트 케이스를 만들어내야만 한다. 테스트를 직접적으로 이끌어내지 못하는 테스트 계획은 무용지물이다.

이제 언급할 마지막 부분이 매우 중요하다. 테스트 계획에서 어떤 테스트 케이스가 작성돼야 하는지 충분히 자세하게 설명되지 않았다면 만들고 있는 애플리케이션의 테스트에 도움이 돼야 한다는 첫 번째 목적을 달성하는 데 실패한 것이다. 테스트를 계획한다는 것은 어떤 테스트가 작성돼야 하는가를 알려줘야 한다. 무엇을 테스트하는지 알게 해줬을 때만 테스트 계획을 마칠 수 있다.

ACC는 제품의 세 가지 관점을 통해 테스트 기획자를 인도한다. 1) 제품의 목적과 목표를 설명하는 형용사와 부사, 2) 제품의 여러 부분과 기능을 일컫는 명사, 3) 제품이 실제로 수행하는 것을 지칭하는 동사다. ACC는 애플리케이션의 목적과 목표를 만족시키는 소프트웨어 역량과 컴포넌트를 테스트할 수 있게 해준다.

## '애트리뷰트'의 A
테스트 계획이나 ACC를 시작할 때 첫 번재로 해당 제품이 사요자와 비즈니스에 왜 중요한지 이유를 밝혀내는 것이 중요하다. 왜 우리가 이것을 만들고 있는지, 이 제품이 출시되면 그 중심 가치는 무엇인지, 왜 고객들이 흥미로워 할 것인지 밝혀내야 한다. 기억할 것은 이러한 사항들을 정의하거나 설명하고자 하는 것이 아니라 단순히 명기하고자 하는 것이다. 짐작하건데 프로젝트 매니저와 제품 기획자, 혹은 개발자들은 시장에서 신경 써야 할 제품 사항들에 대해 각자의 일들을 수행하겠지만, 테스팅 관점에서는 단지 이러한 사항들을 밝혀내고 명기함으로써 테스트에 착수 할 때 테스트해야 할 것들을 확인할 수 있다.

핵심 가치를 애트리뷰트, 컴포넌트, 캐퍼빌리티 분석의 세 단계 프로세스로 문서화했다. 이 중에서 애트리뷰트가 가장 선행돼야 한다.

애트리뷰트는 시스템의 목적과 목표를 설명하는 형용사다. 이러한 형용사들은 제품을 경쟁 제품과 대비해 향상시키는 품질과 특성이다. 이것들을 고객들이 다른 경쟁사 제품 대신 우리의 제품을 선택하는 이유에 대한 설명이 될 것이다. 크롬을 예로 들면 빠른, 안전한, 안정적인, 세련된 같은 형용사가 되고, 이러한 애트리뷰트를 ACC 안에서 문서화하려고 노력해야 한다. 좀 더 멀리 내다보면 각 형용사에 따라 테스트 케이스를 넣을 만한 요소요소를 알고자 함이다. 그렇게 하면 크롬의 빠른, 안전한 등의 애트리뷰트에 대해 얼마만큼 테스팅을 수행해왔는지 알 수 있다. 

일반적으로 제품 매니저는 시스템의 애트리뷰트를 더 세분화한다. 테스터는 이 제품 요구 사항 문서나 팀의 비전과 미션, 혹은 단순히 고객의 관점에서 설명하는 영업 담당의 설명을 통해 애트리뷰트를 받게 된다. 사실, 구글의 영업 사원들이나 마케팅 담당자로부터 애트리뷰트를 얻는 것도 매우 좋은 방법이다. 제품 박스에 쓰여 있는 광고 문구를 상상해보거나, 품질, 가치, 편리의 기준에 어떻게 제품이 부합하는지 생각해보자. 그러면 애트리뷰트들에 대한 올바른 목록을 얻어낼 수 있을 것이다.

프로젝트에 대한 애트리뷰트 선택의 팁을 주자면 다음과 같다.
- 단순함을 유지하라. 작성하는 데 한 시간이나 두 시간이 걸린다면 이 단계에서 너무 오래 시간을 쓴 것이 된다.
- 정확성을 유지하라. 이미 사실이라고 받아들여진 문서나 마케팅 정보에서 온 것이어야 한다.
- 계속 움직여라. 무언가 놓쳤더라도 걱정하지 말라. 결국 놓친 거은 드러나게 될 것이고, 그렇지 않다면 별로 중요하지 않는 것이다.
- 짧게 유지하라. 12개가 넘는다면 좋지 않다. 운영체제에 대해 12개의 주요 애트리뷰트를 뽑았고, 회고 단계에서 12개가 아니라 8개나 9개 정도가 적당했을 거라고 이야기 했다.

애트리뷰트는 제품이 필요한 주된 이유를 설명하고, 그에 따라 테스터가 애플리케이션이 존재하는 궁극적인 목적을 알고 그에 영향을 주는 테스팅을 어떻게 하는지 깨달을 수 있게 한다.

예를 들면 어떤 커뮤니티의 공유 웹사이트를 자유롭게 개발할 수 있는 무료 애플리케이션인 구글 사이트라는 제품의 애트리뷰트를 생각해보자. 많은 엔드 유저 애플리케이션에서도 볼 수 있듯이 구글 사이트는 대부분의 애트리뷰트를 자체 문서에 충분히 제공한다.

사실, 시작하기 페이지를 가진 대부분의 애플리케이션이나 판매 목적의 문서 들은 애트리뷰트를 식별하는 작업을 한다. 그러한 문서가 없다면 영업 담당자나 고객센터에 문의하거나, 데모 비디오나 관련 비디오를 보고 정보를 얻어야 한다.

애트리뷰트는 언급돼야 한다. 당신이 애트리뷰트 리스트를 몇 분 안에 읊어내지 못한다면 효율적인 테스터가 되기 위해 이해해야만 하는 제품 지식을 얻지 못한 것이다. 테스트해야 할 제품을 공부하고, 몇 분 안에 애트리뷰트 리스트를 만들어 낼 수 있게끔 하자.

구글에서 리스크를 문서화하기 위해 문서부터 스프레드시트를 다루는 많은 툴을 사용하는데, 그 중에 구글 테스트 분석기라고 불리는 산업 엔지니어에 의해 제작된 커스텀 툴이 있다. 사실 어떤 툴을 사용하는가는 중요하지 않다. 단지 이 툴들 중 하나를 선택해 애트리뷰트를 모두 작성하게 하는 데 점을 두도록 한다.

## '컴포넌트'의 C
컴포넌트는 시스템의 여러 부분과 기능을 이컫는 명사이며, 애트리뷰트가 완료된 다음 나열돼야 할 것들이다. 컴포넌트는 목표하는 시스템을 만들기 위해 함께 사용되는 벽돌과 같은 것이다. 온라인 스토어에 장바구니와 구매하기 기능 같은 것이 컴포넌트이며, 어떤 소프트웨어인가를 결정짓는 주요 코드 부분들이 컴포넌트다. 사실, 컴포넌트들은 테스터가 가장 많이 테스트하는 것이기도 하다.

컴포넌트들은 쉽게 알아낼 수 있으며, 설계 문서 어딘가에 이미 언급돼 있기도 하다. 큰 시스템에선 아키텍처 다이어그램에서 큰 박스들로 표현되며, 버그 데이터베이스에 레이블로 표시되기도 하고, 프로젝트 페이지나 문서에 명시적으로 언급되기도 한다. 작은 프로젝트들에선 코드 안의 클래스와 객체들이 컴포넌트다. 어떤 경우이든 개발자에게 가서 "어떤 컴포넌트를 작업하고 있어요?"라고 물으면 쉽게 컴포넌트 리스트를 얻을 수 있다.

애트리뷰트와 함께 제품의 컴포넌트를 어느 정도로 사에하게 알아내는가가 매우 중요하다. 너무 자세하면 숲을 볼 수가 없고, 오히려 더 좋지 않을 수 있다. 너무 상세하지 않으면 애초에 살펴볼 피요도 없게 된다. 10개 정도의 컴포넌트로 나뉠 수 있는 단위로 쪼개는 것이 좋으며, 20개라면 큰 시스템이 아니고서야 너무 많다. 자잘한 것들은 언급하지 않는 것도 좋다. 자잘한 것들은 다른 컴포넌트의 일부이거나 엔드 유저가 신경 쓸 만큼 중요한 것이 아니다.

사실, 애트리뷰트와 컴포넌트를 나열하는 데 몇 분이면 충분해야 한다. 컴포넌트들에 무엇이 있는지 말하는데 버벅 댄다면 당신은 제품에 대해 심각하게 모르고 있다고 할 수 있으며, 빨리 파워 유저 정도의 레벨이 되게 시간을 쏟아야 한다. 실제 파워 유저들은 누구나 애트리뷰트를 순식간에 나열할 수 있으며, 소스코드와 개발 문서에 접근할 수 있는 내부인 역시 컴포넌트들을 순식간에 나열할 수 있어야 한다. 당연히 테스터들도 파워 유저나 내부인처럼 할 수 있어야 한다.

마지막으로 완성도에 대해서는 걱정하지 말자. 전체 ACC 프로세스는 어떤 무언가를 굉장히 빨리 작업하고 반복하는 것에 기반을 둔다. 다음에 설명할 캐퍼빌리티 부분에 도달하면 놓친 애트리뷰트나 컴포넌트를 다시 털어내야 할 것이다.

## '캐퍼빌리티'의 C
캐퍼빌리티는 시스템이 실제로 수행하는 것을 지칭하는 동사다. 캐퍼빌리티는 사용자 명령을 수행하는 세스템 동작을 말한다. 캐퍼빌리티는 입력에 대한 반응이며, 질의에 대한 대답이고, 사용자의 목적을 달성하기 위해 완료하는 활동이다. 삿ㄹ, 캐퍼빌리티는 사용자가 당신의 소프트웨어를 선택해 사용하는 중요한 이유가 된다. 즉, 사용자들이 원하는 기능이 있고, 당신의 소프트웨어는 그것을 제공 한다.

크롬을 예로 들면 웹 페이지를 렌더링하는 것과 플래시 파일을 재생하는 캐퍼빌리티가 있다. 크롬은 클라이언트들을 동기화할 수 있으며, 문서를 다운로드할 수 있다. 이러한 모든 캐퍼빌리티와 더 많은 캐퍼빌리티들이 크롬 웹 브라우저를 대표 한다. 반면 쇼핑 앱의 경우는 제품 검색과 판매를 완료하는 캐퍼빌리티를 갖고 있으며, 애플리케이션이 어떤 태스크를 수행할 수 있다면 이 태스크는 하나의 캐퍼빌리티로 명명된다.

캐퍼빌리티는 애트리뷰트와 컴포넌트 사이의 교차점에 위치한다. 컴포넌트는 제품의 애트리뷰트를 만족시키는 기능을 수행하며, 이 활도으이 결과가 사용자에게 캐퍼빌리티를 제공한다. 크롬은 웹 페이지를 빠르게 랜더링한다. 크롬은 플래시 파일을 안전하게 재생한다. 당신의 제품이 애트리뷰트와 컴포넌트의 교차점에서 커버하지 않는 무언가를 갖고 있다면 상관이 없거나, 제품에서 쓸모 없는 것일 것이다. 제품의 주요 가치를 반영하지 않는 캐퍼빌리티는 빼야 할 뱃살 같은 것이고, 얻는 이익에 비해 잠재적으로 오류가 큰 부분이 된다. 이러한 것들이 캐퍼빌리티가 필요한 이유이며, 찾아내지 못했다면 당신이 제품을 이해하지 못했던 것이다. 제품을 이해하지 못하는 것은 테스팅 업계에선 있을 수 없는 일이다. 프로젝트에서 개개의 엔지니어가 그 제품이 사용자에게 주는 가치를 이해해야 하며, 그 개개의 엔지니어는 바로 테스터다!

온라인 쇼핑 사이트의 캐퍼빌리티를 예로 들면 다음과 같다.

- 장바구니에서 항복 추가/삭제하기 : 장바구니 컴포넌트의 캐퍼빌리티로서 '직관적인 UI' 애트리뷰트를 다룬다.
- 신용카드 정보를 수집하고 데이터를 검증하기 : 장바구니 컴포넌트의 캐퍼빌리티로서 '편리한' 애트리뷰트와 '통합된(예를 들면 지불 시스템과의 연동)' 애트리뷰트를 다룬다.
- HTTPS를 통한 결제 정보 처리하기 : 장바구니 컴포넌트가 '보안' 애틀뷰트를 따르려 할 때의 캐퍼빌리티다.
- 사용자들이 보고 있는 제품에 기반을 두고 추천 상품을 제공하기 : 이는 '편리한' 애트리뷰트를 다루는 검색 컴포넌트의 캐퍼빌리티다.
- 배송비 계산하기 : 이것은 '빠른'과 '보안' 애트리뷰트를 다루는 배송 컴포넌트의 캐퍼빌리티다.
- 재고 여부 보여주기 : 이것은 '편리한'과 '정확한' 애트리뷰트를 다루는 검색 컴포넌트의 캐퍼빌리티다.
- 구매 미루기 기능 제공하기 : 이것은 '편리한' 애트리뷰트를 다루는 장바구니 컴포넌트의 캐퍼빌리티다.
- 키워드, SKU, 카테고리에 따라 상품 검색하기 : 이것은 '편리한'과 '정확한' 애트리뷰트를 만족시키려는 검색 컴포넌트의 캐퍼빌리티다. 일반적으로 각 검색 카테고리를 각각의 캐퍼빌리티로 나누는 것이 좋다.

캐퍼빌리티 수가 명백히 많아졌고, 당신이 테스트할 수 있는 모든 것을 나열하는 것 같다면 ACC에 대해 익숙해지고 있는 것이다. 전체 아이디어는 검증 대상 시스템의 가장 중요한 캐퍼빌리티를 작업 순서에 따라 빠르고 간결하게 나열하는 것이다.

캐퍼빌리티는 일반적으로 사용자 중심이며, 시스템이 무엇을 해야 하는지 사용자 관점으로 쓰여진다. 그리고 애트리뷰트나 컴포넌트보다 훨씬 많다. ACC의 처음 두 단계는 간결하게 가져가므로, 캐퍼빌리티의 집합은 시스템이 할 수 있는 모든 일을 설명할 수 있어야 한다. 그러므로 풍부한 기능과 애플리케이션의 복잡성을 따지게 되면 그 개수가 더 많아진다.

구글의 크고 복잡한 애플리케이션에는 대략 수백 개의 캐퍼빌리티가 있으며, 작은 애플리케이션은 수십 개가 있다. 물론 캐퍼빌리티 수가 작아 테스터가 필요 없이 개발자나 초기 사용자가 테스트할 수 있는 애플리케이션들도 있다. 그러므로 캐퍼빌리티의 수가 20개가 안 되는 애프릴케이션을 테스트해야 한다면 그 프로젝트에 테스터의 존재 자체가 필요한지 묻고 싶을 것이다.

캐퍼빌리티의 가장 중요한 관점은 그것들이 테스트 가능하다는 점이다. 이것이 우리가 캐퍼빌리티를 작성하라고 주장하는 가장 중요한 이유다.

캐퍼빌리티는 동사를 이용해서 설명을 하는 문장으로 써지는데, 이는 주요 활동 중 하나인 테스트 케이스 작성을 통해 각 캐퍼빌리티가 정확하게 구현됐는지를 확인하고 사용자에게 유용한 경험을 제공하는지를 확인하기 위해 사용한다.

이에 대한 것은 뒤에서 캐퍼빌리티를 테스트 케이스로 변환하는 부분에서 더 자세히 논의할 것이다.

캐퍼빌리티가 언 정도까지 추상화돼야 하는가는 구글 TE 사이에서 굉장한 논의거리다. 정의에 의하면 캐퍼빌리티는 단일 액션이 아니므로, 하나의 캐퍼빌리티는 여러 유스케이스를 설명할 수도 있다. 앞의 쇼핑 예제의 캐퍼빌리티들은 어떤 상품이 장바구니에 있거나 특정 검색의 결과가 무엇인지는 언급하지 않았다. 그것들은 사용자가 연관된 일반적인 작업에 대해서만 설명한다. 실제로 테스트 되지 않을 사항까지 자세히 언급하는 것은 너무 방대하기 때문에 의도적으로 제외한 것 이다. 가능한 모든 검색과 장바구니 설정에 대해서 테스트할 수 없으므로, 실제로 테스트돼야만 하는 캐퍼빌리티에 대해서만 테스트 케이스로 변환한다.

캐퍼빌리티는 그것을 실제 테스트로 실행하기 위해 필요한 모든 정보를 갖고 있지는 않으므로 테스트 케이스 자체는 아니다. 우리는 캐퍼빌리티에 정확한 값이나 실제 데이터를 넣고자 하지 않는다. 캐퍼빌리티는 사용자가 쇼핑할 수 있게 하는 것인 반면, 테스트 케이스는 사용자가 쇼핑하는 것이 무엇인가를 언급해야 한다. 캐퍼빌리티는 소프트웨어가 받아들일 수 있고, 사용자가 요청할 수 있는 액션에 대한 일반적인 개념이다. 캐퍼빌리티들은 일반적이어야 한다. 그것들이 테스트와 값을 암시하더라도 테스트 그 자체는 아니다.

그림에 나온 구글 사이트 예제를 살펴보면 그림의 표에서 x축은 애트리뷰트를, y축은 컴포넌트를 보여준다. 이것이 우리가 캐퍼빌리티를 애트리뷰트와 컴포넌트로 연결시키는 방법이다. 먼저 눈치 채야 할 것은 많은 칸들이 비어 있다는 점이다. 이것은 당연하며 모든 애트리뷰트가 모든 컴포넌트에 영향을 주는 것은 아니기 때문이다. 크롬에서는 오직 몇 개의 컴포넌트만 빠르거나 안전해야 할 의무가 있다. 다른 컴포넌트들은 영향이 없다는 것을 의미하기 위해 빈칸으로 남아 있다. 이러한 빈칸들은 특정 애트리뷰트/컴포넌트 짝에 대해서는 테스트할필요가 없음을 뜻한다.

캐퍼빌리티 표의 각 열과 행은 어떤 측면에서 기능의 단면을 나타낸다. 하나의 열이나 행은 애플리케이션의 기능을 테스트 가능하도록 쪼개는 좋은 방법을 제시한다. 테스트 매니저는 각 행을 분산된 테스트 팀에게 할당하거나, 행이나 열을 테스트하는 버그 배시를 가진다.

숫자 값을 가진 칸은 컴포넌트가 만족시켜야 할 애트리뷰트가 제공하는 캐퍼빌리티 숫자다. 숫자가 클수록 특정 교차점의 테스트 포인트가 더 크다. 예를 들면 페이지 뷰 컾모넌트는 '공유' 애트리뷰트에게 다음 세 가지 캐퍼빌리티로 영향을 미친다.

- 협업자가 문서에 접근할 수 있게 만들어라.
- 협업자와 페이지 관리 의무를 공유하라.
- 페이지에서 협업자의 위치를 보여줘라.

이러한 캐퍼빌리티는 페이비 쥬, 공유에 관한 것 중 테스트해야 할 내용들을 쉽게 알려준다. 이를 이용해 곧바로 테스트 케이스를 작성하거나 캐퍼빌리티를 조합해 더 큰 유스케이스나 테스트 시나리오에 대해 테스트 케이스를 작성할 수도 있다.

좋은 캐퍼빌리티를 작성하려면 몇 가지 규칙이 필요하다. 캐퍼빌리티를 작성하는 데 도움이 되는 몇 가지 사항은 다음과 같다.

1. 캐퍼빌리티는 어떤 액션에 대해 작성돼야 하며, 테스트하고자 하는 애플리케이션을 사용해 사용자가 하고자 하는 것을 전달해야 한다.
2. 캐퍼빌리티는 설명하는 동작에 대해 어떤 변수들이 테스트 케이스를 작성하는데 필요한지 테스터가 이해할 수 있게 충분한 가이드를 제공해야 한다. 예를 들어 https를 이용한 결제 시스템은 테스터가 어떤 종류의 결제 방식을 사용해 https를 통한 트랜잭션을 검증하는지 이해할 필요가 있다. 당연히 이를 달성하기 위해서는 엄청난 일들을 해야만 한다. 팀에 들어온 새로운 테스터가 한 가지라도 결제 방식을 놓칠 수 있다면 모든 수단을 동원해 모든 종류의 결제 방시을 나타내는 캐퍼빌리티들을 만들어야 한다. 하지만 모든 테스터가 결제 방식에 대해 잘 이해하고 있다면 캐퍼빌리티를 하나로 추상화하는 것으로 충분하다. 마찬가지로 팀이 https도 잘 이해하고 있다면 그 자체가 캐퍼빌리티가 된다. 캐퍼빌리티들은 추상화돼야 하는 것들이다. 모든 내용을 캐퍼빌리티로 문서화 하겠다는 함정에 빠지지 말자. 상세 사항은 테스트 케이스나 탐험적 테스팅에서 테스터 자신이 제공하게 하면 된다.
3. 캐퍼빌리티는 다른 캐퍼빌리티와 함게 구성돼야 한다. 사실 사용자 스토리나 유스케이스들은 여러 캐퍼빌리티를 이용해 설명돼야만 한다. 사용자 스토리가 이미 만들어진 캐퍼빌리티로 작성될 수 없다면 놓친 캐퍼빌리티가 있거나 캐퍼빌리티가 너무 추상화돼 있는 것이다.

캐퍼빌리티들은 사용자 스토리로 변경하는 과정은 테스팅에 큰 유연성을 줄 수 있는 선택 가능한 중간 단계다. 사실 구글에서 외부 협렵 업체와 일하거나 크라우드 소싱 업체를 통해 탐색적 테스팅을 하려고 할 때에는 더 자세한 테스트 케이스 보다는 일반적인 사용자 스토리를 선호한다. 테스트 케이스는 상세하기 때문에 협력 업체들이 계속적으로 수행하기에는 지겨운 반면, 사용자 스토리는 상세한 부분을 자유롭게 선택할 수 있기 때문에 테스팅이 좀 더 재밌고, 지루하고 단순 반복적인 실행에서 오는 실수를 줄일 수 있다.

사용자 스토리이건 테스트 케이스이건 둘 다 궁극적인 목표다. 캐퍼빌리티를 테스트 케이스로 변경하는 일반적인 가이드를 제공하면 다음과 같다. 이러한 것들음 목표이지 절대적으로 따라야 할 것은 아니라는 점을 상기하자.

- 모든 캐퍼빌리티는 최소한 하나의 테스트 케이스에 연결돼야 한다. 캐퍼빌리티가 문서화될 정도로 중요하다면 테스트될 정도로도 중요한 것이다.
- 많은 캐퍼빌리티가 하나 이상의 테스트 케이스를 필요로 한다. 다양한 입력 값, 입력 순서, 시스템 사양, 사용되는 데이터 등이 잇을 수 있기 때뭄ㄴ에 여러 테스트 케이스가 피룡하다. "어떻게 소프트웨어를 깰 것인가"에 나오는 공격과 '탐색적 소프트웨어 테스팅' 에 나오는 투어들은 테스트 케이스 선택에 대한 좋은 지침을 제공하고, 캐퍼빌리에서 버그를 찾는 테스트 케이스로 변환할 때 필요한 데이터와 입력 값에 대해 어떻게 생각하면 되는지 알려준다.

모든 캐퍼빌리티가 동등하지 않으며, 그 중 일부는 다른 것들보다 중요하다. 다음 절에서 설명할 프로세스의 다음 단계는 캐퍼빌리티를 중요성에 따라 구분하기 위해 리스크를 캐퍼빌리티에 어떻게 적용하는지 알아본다.

ACC가 완료된 후 예산과 시간이 문제가 되지 않는다면 우리가 테스트할 수 있는 모든 것을 얼급할 수 있다. 예산과 시간은 매우 중요한 문제이기 때문에 테스트할 수 있는 것들을 우선순위화 하는 데 도움이 된다. 구글에서는 리스크 분석이라는 우선순위화 방법을 쓰며, 다음 절에서 이에 대한 내용을 다룰 것이다.

```
예제 : 구글플러스의 애트리뷰트, 컴포넌트, 캐퍼빌리티
ACC는 문서, 스프레드시트 혹은 냅킨 위에 끄적일 수 있을 정도로 빠르게 수행할 수 있다. 구글 플러스에서 쓰인 간략화된 ACC 예제를 여기에서 다뤄봤다.

- 구글플러스 애트리뷰트(구글플러스의 실무적인 내용을 지켜보면서 독립적으로 만듦)
  Social : 사용자에게 정보를 공유시키고, 그들이 해야 할 일에 힘을 실어 준다.
  Expressive : 사용자는 기능을 통해 자신을 표현 가능해야 한다.
  Easy : 직관적인, 어떻게 하는지, 무엇을 하고자 하는지 쉽게 알 수 있어야 한다.
  Relevant : 사용자가 관심 있는 정보만 보여준다.
  Extensible : 구글의 속성이나 서드파티 사이트, 애플리케이션과 통합 가능해야 한다.
  Private : 사용자 데이터는 공유되지 말아야 한다.
  
- 구글플러스 컴포넌트(아키텍처 문서로부터 얻어냄)
  사용자 정보 : 로그인한 사용자의 정보와 환경설정
  지인 : 사용자가 연결한 사람들의 프로필 정보
  스트림 : 소식, 코멘트, 알림, 사진 등에 대한 우선순위화된 스트림
  써클 : '친구, '동료' 등과 같이 지인들을 구분하는 그룹
  알림 : 소식에 사용자가 언급이 된 경우 알려주는 표식
  소식 : 사용자나 지인들로부터 올라온 포스트
  댓글 : 소식, 사진, 동영상 등에 남기는 댓글
  사진 : 사용자나 지인들로부터 올라온 사진들
  
- 구글플러스 캐퍼빌리티
  사용자 정보 : 
  Social : 사용자 정보와 설정을 친구와 연락처에 공유한다.
  Expressive : 사용자는 온라인 버전의 자신을 창조할 수 있다.
  Expressive : 구글 플러스 사용 방법을 개인화한다.
  Easy : 쉽게 정보를 입력하고 업데이트하며 전파한다.
  Extensible : 사용자 정보를 적당한 접근 권한과 함께 애플리케이션에 공유한다.
  Private : 개인 정보가 노출되지 않게 설정한다.
  Private : 접근이 허락되거나 적당한 대상에게만 데이터를 공유한다.
  
  지인 : 
  Social : 사용자의 친구, 동료, 가족에게 연결할 수 있다.
  Expressive : 다른 사용자의 정보는 개인화돼 있고, 쉽게 구분 가능한다.
  Easy : 사용자의 연락처를 쉽게 관리할 수 있는 툴을 제공한다.
  Relevant : 연관 정보에 따라 사용자를 필터링 할 수 있다.
  Extensible : 허가된 서비스나 애플리케이션에 연락처 정보를 제공한다.
  Private : 허가된 대상 안에서 사용자의 연락처를 보호한다.
  
  스트림 : 
  Social : 사용자의 소셜 네트워크에서 업데이트가 있을 때 알려준다.
  Relevant : 사용자가 관심 있어 할 만한 업데이트만 필터링한다.
  Extensible : 서비스왕 ㅐ플리케이션에 스트림 업데이트를 제공한다.
  
  써클 : 
  Social :관계에 따라 연락처를 써클에 넣어 그룹화한다.
  Expressive : 새로운 써클은 사용자가 정의한 의미에 따라 생성된다.
  Easy : 써클에 연락처 추가, 수정, 삭제를 제공한다.
  Extensible : 써클을 생성하고 수정할 수 있다.
  Private : 서비스와 애플리케이션에 써클 데이터를 제공한다.
  
  알림 : 
  Easy : 알림 사항을 간결하게 보여준다.
  Extensible : 다른 서비스와 애플리케이션에 알림을 보낸다.
  
  행아웃 : 
  Social : 사용자는 행아웃하기 위해 써클을 초대할 수 있다.
  Social : 사용자는 행아웃을 누구에게나 공개할 수 있다.
  Social : 다른 사용자가 자신의 스트림에 접근할 때 행아웃 알림을 받는다.
  Easy : 몇 번의 클릭으로 행아웃을 생성하건 참가할 수 있다.
  Easy : 동영상과 소리 입력은 한 번의 클릭으로 설정을 변경할 수 있다.
  Easy : 존재하는 행아웃에 사용자를 더 추가할 수 있다.
  Expressive : 행아웃에 조인하기 전에 사용자는 다른 이들에게 어떻게 보일지 미리보기를 할 수 있다.
  Extensible : 사용자는 행아웃 중에 채팅을 할 수 있다.
  Extensible : 행아웃에 유투브의 동영상을 추가할 수 있다.
  Extensible : 설정에서 디바이스를 설정하고 조정할 수 있다.
  Extensible : 웹캠이 없는 사용자는 오디오를 통해 행아웃에 참가할 수 있다.
  Private : 오직 초대된 손님만 행아웃에 참가할 수 있다.
  Private : 오직 초대된 손님만 행아웃의 알림을 받는다.
  
  소식 : 
  Expressive : 사용자의 생각을 표현한다.
  Private : 의도한 사용자에게만 소식을 제한다.
  
  댓글 : 
  Expressive : 댓글을 통해 사용자의 생각을 표현한다.
  Extensible : 다른 서비스와 애플리케이션에게 댓글 소식을 보낸다.
  Private : 의도한 사용자에게만 소식을 제한한다.
  
  사진 : 
  Social : 사용자는 자신의 사진을 지인과 친구들에게 공유할 수 있다.
  Easy : 사용자는 쉽게 사진을 업로드할 수 있다.
  Easy : 사용자는 쉽게 다른 곳의 사진을 가져올 수 있다.
  Extensible : 다른 사진 서비스와 통합된다. 
  Private : 사진은 제한돼 허락된 사용자에게만 보여준다.
  
```


